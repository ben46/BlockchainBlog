# arbitrum usenix 演讲稿笔记
验证者: L1上的验证者, 一般只有一个(也可称为法官)

要解决两个问题

第一, 隐私性

第二, 可扩展


如何实现

简单一句: 原来的vm验证变成了数字签名验证.

我的理解: 把vm放到链下运行, 使用激励机制, 让arbi矿工验证数字签名, 确认对方vm的行为(等于原来的链上vm验证被简单的数字签名代替了)
```
原文:

Arbitrum 使
⽤机制设计来激励各⽅在链下就 VM 的⾏为达成⼀致，因此
Arbitrum 矿⼯只需验证数字签名即可确认各⽅已就 VM 的⾏为
达成⼀致。在各⽅⽆法在链下达成⼀致的情况下，Arbitrum 仍然
允许诚实的各⽅在链上推进 VM 状态。
```

如果有人作恶,矿工可以挑战,来抓出坏人和惩罚坏人. 
```
原文:

如果⼀⽅试图对 VM 的⾏为撒谎，验证者（或矿⼯）将通过使⽤利
⽤ Arbitrum 虚拟机架构特性的⾼效基于挑战的协议来识别和惩
罚不诚实的⼀⽅。以这种⽅式将 VM ⾏为的验证移⾄链外可显着改
善可扩展性和隐私性。我们描述了 Arbitrum 的协议和虚拟机架
构，并展⽰了⼀个⼯作原型实现。
```

arbi的验证者(L1法官),只需要验证每份合同的签名, 就可以裁定争议, 无需重新把所有的指令都运行一遍.
arbi合约还能私下执行, 只发布一个合约当前状态的hash(等于是storage都没有了...)
```
我们介绍了 Arbitrum 的设计和实施，这是⼀种解决这些缺点的智
能合约新⽅法。仲裁合约对于验证者来说管理起来⾮常便宜。 （如
下所述，我们通常使⽤术语验证者来指代底层共识机制。例如，在⽐
特币协议中，⽐特币矿⼯是验证者。）如果各⽅根据激励⾏事，
Arbitrum 验证者只需要验证⼀些数字每份合同的签名。即使当事
⽅违背他们的动机，Arbitrum 验证者也可以有效地裁定关于合约
⾏为的争议，⽽⽆需检查合约对多个指令的执⾏情况。 Arbitrum
还允许合约私下执⾏，只发布合约状态的（可销售的）哈希值。
```

管理者可以指定经理人运行VM,经理人其实不多的.
```
在 Arbitrum 中，各⽅可以将智能合约实现为对合约规则进⾏
编码的虚拟机 (VM)。 VM 的创建者为 VM 指定⼀组管理器。
Arbitrum 协议提供了⼀种任意信任的保证：任何⼀个诚实的管理
者都可以强制虚拟机按照虚拟机的代码⾏事。对 VM 结果感兴趣的
各⽅可以⾃⼰作为经理或指定他们信任的⼈代表他们管理 VM。对于许多合同，经理
⼈的⾃然集合在实践中会⾮常⼩。
```
这样验证者就不需要运行vm, 只需要验证vm状态的hash就行了.
如果两个管理者有分歧,那么验证者将使用二分法解决分歧, 其中一个管理者提交一个指令的验证.
错的那方向验证者支付罚款.
```
依赖管理器，⽽不是要求每个验证者模拟每个 VM 的执⾏，允
许 VM 的管理器以更低的成本提升 VM 的状态给验证者。验证者只跟踪 VM 状态的散列，⽽不是完整状态。
Arbitrum 为管理⼈员创造了激励机制，让他们在带外就 VM 将做
什么达成⼀致。任何由所有管理者认可的状态改变（并且不超⽀
VM 的资⾦）将被验证者接受。如果与激励相反，两个管理者对 VM
将做什么有不同意⻅，则验证者使⽤⼆分法将分歧缩⼩到执⾏单
个指令，然后⼀个管理者提交该指令的简单证明验证者可以⾮常
有效地检查执⾏情况。错误的经理向验证者⽀付巨额罚款，以阻⽌
分歧。
```
略
```
各⽅可以向 VM 发送消息和货币，⽽ VM 本⾝可以向其他 VM
或其他⽅发送消息和货币。 VM 可能会根据收到的消息采取⾏
动。 Verifier 跟踪 VM 收件箱的哈希值。

Arbitrum VM 和协议的架构旨在使验证者尽可能快速和简单
地解决争议。设计细节将在本⽂后⾯出现。

Arbitrum ⼤⼤降低了智能合约的成本。如果参与者根据他们
的激励⾏事，那么验证者将永远不必模仿或验证任何 VM 的⾏
为。在这种情况下，验证者的唯⼀职责是进⾏简单的簿记以跟踪货
币持有量、消息收件箱的哈希值以及每个 VM 的单个哈希状态值。
如果参与者的⾏为不合理，可能需要验证者做少量的额外⼯作，但
验证者将以牺牲⾮理性⽅为代价来（过度）补偿这项⼯作。
```
不会泄露vm的代码,
```
作为先前原则的必然结果，Arbitrum VM 可以是私有的，从这
个意义上说，VM 可以创建并执⾏到完成⽽不会泄露 VM 的代码或
其执⾏，除了它发送的消息和付款的内容和时间，并且(saltable)
其状态的哈希值。 VM 的任何管理员都必须能够透露有关该 VM
的信息，但是如果管理员想要维护 VM 的隐私，他们可以这样做。

Arbitrum 与共识⽆关，这意味着它假定存在发布交易的共识
机制，但 Arbitrum 的设计同样适⽤于任何共识机制，包括单个中
⼼化发布者、基于仲裁的共识系统或 Nakamoto 共识⽤于⽐特
币 [26]。

此外，现有的智能合约系统可以作为这种共识机制，假设它可以将
Arbitrum 的规则编码为智能合约。在本⽂中，我们将共识实体或
系统称为验证者（并将该共识系统中的参与者称为验证者）。
```
# 为什么扩展智能合约很困难

实现智能合约 VM 最明显的⽅法是让加密货币系统中的每个矿⼯模拟每个 VM 执⾏的每个步骤。这具有简单的优点，但它对可扩展性施加了严格的限制。验证 VM 执⾏的⾼成本可能表现为验证者的困境 [22]。由于涉及由 VM 执⾏代码的交易的验证成本很⾼，因此本应验证这些交易的⼀⽅有动机通过接受交易⽽不验证它们来搭便⻋，希望阻⽌(1) 不当⾏为由其他⽅进⾏验证，或 (2) 任何差异将不会被其他潜在验证者检测到，因为他们也不执⾏验证。这可能会导致⼀种平衡，在这种平衡中，⼀些交易在很少或没有验证的情况下被接受。
相反，在所有矿⼯都诚实地进⾏验证的情况下，⼀个矿⼯可以通过包括⼀个耗时的计算来利⽤这⼀点，这将花费其他矿⼯⼤量的时间来验证。当所有其他矿⼯都在进⾏验证时，包含这种计算量⼤的交易的矿⼯可以在挖掘下⼀个区块时抢占先机，从⽽获得不成⽐例的收集下⼀个区块奖励的机会。存在这种困境是因为验证 VM 执⾏的成本很⾼。
⼀种扩展验证的⽅法（例如在 TrueBit [30] 中使⽤）依赖于参与游
戏，这是⼀种机制设计⽅法，旨在诱导有限但⾜够数量的参与⽅来验
证每个 VM 的执⾏。这些系统⾯临我们所说的参与困境，即如何防⽌
⼥巫攻击，在这种攻击中，可能诚实或不诚实的单个验证者声称⾃⼰
是多个验证者，这样做可以将其他验证者赶出系统.

在本节中，我们证明了基于参与博弈的⽅法的新形式障碍。这个想法
是玩家将“参与”⼀个代价⾼昂的过程。考虑以下游戏：

在本⽂的上下⽂中，将参与视为“验证计算”。验证计算需要花费
⼀些费⽤，但是⼀旦你验证了它，你就可以声称已经从任何数量的额
外⼥巫⾝上免费验证了它，⽽这些⼥巫与“真正的”验证者没有区别。
然后⽬标将是设计⼀个参与游戏（即奖励函数 f(·)），使得在均衡状
态下，没有玩家对 Sybil 有任何激励，并且期望数量的玩家参与，因此
验证者的表观数量等于作为验证者的独⽴玩家的实际数量。

Verifier是验证交易有效性并发布已接受交易的全局实体或分
布式协议。验证者可能是中央实体或分布式多⽅共识系统，例如分
布式仲裁系统、中本聪共识协议 [26] 中的全球矿⼯集合，或者本
⾝是现有加密货币的智能合约。由于 Arbitrum 的设计对于使⽤哪
种类型的共识系统是不可知的，为了简洁起⻅，我们对正在运⾏的
任何共识系统都使⽤单数术语 Verifier。

Arbitrum VM 是使⽤特殊事务创建的，它指定了 VM 的初始状态
哈希、VM 的管理器列表和⼀些参数。如下所述，状态散列表⽰对
VM 状态（即其代码和初始数据）的加密承诺。可以同时存在任意
数量的 VM，通常具有不同的管理器。

创建 VM 后，管理⼈员可以采取措施使该 VM 的状态发⽣变
化。 Arbitrum 协议提供了⼀种任意信任的保证：任何⼀个诚实
的管理者都可以强制 VM 的状态变化与 VM 的代码和状态⼀致，
即根据 AVM 规范是有效的执⾏。

断⾔指出，如果某些先决条件成⽴，VM 的状态将以某种⽅式改变。如果 (1) 断⾔的先决条件成⽴，(2) VM 未处于停⽌状态，并且 (3) 断⾔不会花费⽐ VM 拥有的更多的资⾦。断⾔包含 VM 新状态的哈希值和 VM采取的⼀组操作，例如发送消息或货币。
