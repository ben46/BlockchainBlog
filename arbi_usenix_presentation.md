# arbitrum usenix 演讲稿笔记
验证者: L1上的验证者, 一般只有一个(也可称为法官)

要解决两个问题

第一, 隐私性

第二, 可扩展


如何实现

简单一句: 原来的vm验证变成了数字签名验证.

我的理解: 把vm放到链下运行, 使用激励机制, 让arbi矿工验证数字签名, 确认对方vm的行为(等于原来的链上vm验证被简单的数字签名代替了)
```
原文:

Arbitrum 使
⽤机制设计来激励各⽅在链下就 VM 的⾏为达成⼀致，因此
Arbitrum 矿⼯只需验证数字签名即可确认各⽅已就 VM 的⾏为
达成⼀致。在各⽅⽆法在链下达成⼀致的情况下，Arbitrum 仍然
允许诚实的各⽅在链上推进 VM 状态。
```

如果有人作恶,矿工可以挑战,来抓出坏人和惩罚坏人. 
```
原文:

如果⼀⽅试图对 VM 的⾏为撒谎，验证者（或矿⼯）将通过使⽤利
⽤ Arbitrum 虚拟机架构特性的⾼效基于挑战的协议来识别和惩
罚不诚实的⼀⽅。以这种⽅式将 VM ⾏为的验证移⾄链外可显着改
善可扩展性和隐私性。我们描述了 Arbitrum 的协议和虚拟机架
构，并展⽰了⼀个⼯作原型实现。
```

arbi的验证者(L1法官),只需要验证每份合同的签名, 就可以裁定争议, 无需重新把所有的指令都运行一遍.
arbi合约还能私下执行, 只发布一个合约当前状态的hash(等于是storage都没有了...)
```
我们介绍了 Arbitrum 的设计和实施，这是⼀种解决这些缺点的智
能合约新⽅法。仲裁合约对于验证者来说管理起来⾮常便宜。 （如
下所述，我们通常使⽤术语验证者来指代底层共识机制。例如，在⽐
特币协议中，⽐特币矿⼯是验证者。）如果各⽅根据激励⾏事，
Arbitrum 验证者只需要验证⼀些数字每份合同的签名。即使当事
⽅违背他们的动机，Arbitrum 验证者也可以有效地裁定关于合约
⾏为的争议，⽽⽆需检查合约对多个指令的执⾏情况。 Arbitrum
还允许合约私下执⾏，只发布合约状态的（可销售的）哈希值。
```

管理者可以指定经理人运行VM,经理人其实不多的.
```
在 Arbitrum 中，各⽅可以将智能合约实现为对合约规则进⾏
编码的虚拟机 (VM)。 VM 的创建者为 VM 指定⼀组管理器。
Arbitrum 协议提供了⼀种任意信任的保证：任何⼀个诚实的管理
者都可以强制虚拟机按照虚拟机的代码⾏事。对 VM 结果感兴趣的
各⽅可以⾃⼰作为经理或指定他们信任的⼈代表他们管理 VM。对于许多合同，经理
⼈的⾃然集合在实践中会⾮常⼩。
```
这样验证者就不需要运行vm, 只需要验证vm状态的hash就行了.
如果两个管理者有分歧,那么验证者将使用二分法解决分歧, 其中一个管理者提交一个指令的验证.
错的那方向验证者支付罚款.
```
依赖管理器，⽽不是要求每个验证者模拟每个 VM 的执⾏，允
许 VM 的管理器以更低的成本提升 VM 的状态给验证者。验证者只跟踪 VM 状态的散列，⽽不是完整状态。
Arbitrum 为管理⼈员创造了激励机制，让他们在带外就 VM 将做
什么达成⼀致。任何由所有管理者认可的状态改变（并且不超⽀
VM 的资⾦）将被验证者接受。如果与激励相反，两个管理者对 VM
将做什么有不同意⻅，则验证者使⽤⼆分法将分歧缩⼩到执⾏单
个指令，然后⼀个管理者提交该指令的简单证明验证者可以⾮常
有效地检查执⾏情况。错误的经理向验证者⽀付巨额罚款，以阻⽌
分歧。
```
略
```
各⽅可以向 VM 发送消息和货币，⽽ VM 本⾝可以向其他 VM
或其他⽅发送消息和货币。 VM 可能会根据收到的消息采取⾏
动。 Verifier 跟踪 VM 收件箱的哈希值。

Arbitrum VM 和协议的架构旨在使验证者尽可能快速和简单
地解决争议。设计细节将在本⽂后⾯出现。

Arbitrum ⼤⼤降低了智能合约的成本。如果参与者根据他们
的激励⾏事，那么验证者将永远不必模仿或验证任何 VM 的⾏
为。在这种情况下，验证者的唯⼀职责是进⾏简单的簿记以跟踪货
币持有量、消息收件箱的哈希值以及每个 VM 的单个哈希状态值。
如果参与者的⾏为不合理，可能需要验证者做少量的额外⼯作，但
验证者将以牺牲⾮理性⽅为代价来（过度）补偿这项⼯作。
```
不会泄露vm的代码,
```
作为先前原则的必然结果，Arbitrum VM 可以是私有的，从这
个意义上说，VM 可以创建并执⾏到完成⽽不会泄露 VM 的代码或
其执⾏，除了它发送的消息和付款的内容和时间，并且(saltable)
其状态的哈希值。 VM 的任何管理员都必须能够透露有关该 VM
的信息，但是如果管理员想要维护 VM 的隐私，他们可以这样做。

Arbitrum 与共识⽆关，这意味着它假定存在发布交易的共识
机制，但 Arbitrum 的设计同样适⽤于任何共识机制，包括单个中
⼼化发布者、基于仲裁的共识系统或 Nakamoto 共识⽤于⽐特
币 [26]。

此外，现有的智能合约系统可以作为这种共识机制，假设它可以将
Arbitrum 的规则编码为智能合约。在本⽂中，我们将共识实体或
系统称为验证者（并将该共识系统中的参与者称为验证者）。
```

