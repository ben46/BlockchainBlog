ABI，函数签名和函数选择器

# ABI
四个场景

```
byte4 selector = contract.value.selector
bytes memory data = abi.encodeWithSelector(selector, param1)
(bool suc, bytes memory returnedData) = address(contract).call(data)
require(suc)

return abi.decode(returnedData, (uint256))
```
# 透明代理

代理合约的执行原理: 

当无法匹配函数selector的时候, 函数会调用fallback/receive,接着会使用delegatecall调用逻辑合约

为什么用fallback而不是receive, receive能干的事情也就2300gas

msg.data != null and receive exites => call receive

什么是msg.data, 其实就是calldata, 也就是selector + input params组合

函数选择器 = bytes4 = 8 * 2^16

selector = bytes4(keccak256("burn(uint256)"));

如果出现同一个合约两个函数的选择器一样, 那么就不会通过编译

if 逻辑合约的a函数 = 代理合约的升级函数

管理人通过代理调用a函数的时候, 就会把代理合约升级成一个黑洞合约, 因为选择器是一样的嘛

那么我们禁止管理员调用任何逻辑合约的函数, 就能解决这个问题. (在fallback中校验)

* 管理人只能调用代理合约的升级函数(fallback中把管理员禁了)
* 其他用户不能调用可升级函数 但是可以调用逻辑合约的函数(在upgrade函数中把非管理员禁了)

